1. Перечислите тип данных с плавающей запятой в языке Си

loat, double, long double.Величина с модификатором-типа float занимает 4 байта. Из них 1 байт отводится для знака, 8 бит для избыточной экспоненты и 23 бита для мантиссы.Величина типа double занимает 8 байт в памяти. Ее формат аналогичен формату float. Биты памяти распределяются следующим образом: 1 бит для знака, 11 бит для экспоненты и 52 бита для мантиссы.
----------------------------------------------------------------------------------------------------------------
2. Сколько байт в памяти занимает тип int?

Для 16-разрядных операционных систем — этот тип (int) составляет 2 байта и совпадает с типом short int (можно использовать как short, опуская слово int), для 32-разрядных операционных систем он будет равен 4 байтам и совпадает с длинным целым long int (можно использовать как long, опуская слово int), и в этом случае будет составлять 4 байта. Короткое целое short int, для 16-разрядных операционных систем, 32-разрядных операционных систем, и для большинства 64-разрядных операционных систем составляет — 2 байта. Также в некоторых языках может использоваться тип данных двойное длинное long long, который составляет 8 байт.
Коротко о главном -  int имеет размер 4 байта (32 бита). Минимальное значение -2 147 483 648, максимальное значение 2 147 483 647.
----------------------------------------------------------------------------------------------------------------
3. В каких случаях применяют цикл for ?

for - цикл со счетчиком (заранее известно, сколько раз будет выполняться цикл).
for (инициализация; условие; приращение) оператор;
Цикл for может иметь большое количество вариаций. В наиболее общем виде принцип его работы следующий. Инициализация — это присваивание начального значения переменной, которая называется параметром цикла. Условие представляет собой условное выражение, определяющее, следует ли выполнять оператор цикла (часто его называют телом цикла) в очередной раз. Оператор приращение осуществляет изменение параметра цикла при каждой итерации. Эти три оператора (они называются также секциями оператора for) обязательно разделяются точкой с запятой. Цикл for выполняется, если выражение условие принимает значение ИСТИНА. Если оно хотя бы один раз примет значение ЛОЖЬ, то программа выходит из цикла и выполняется оператор, следующий за телом цикла for.
----------------------------------------------------------------------------------------------------------------
4. В каких случаях применяют цикл do .. while ?

В отличие от циклов for и while, которые проверяют свое условие перед итерацией, do-while делает это после нее. Поэтому цикл do-while всегда выполняется как минимум один раз. Общая форма цикла do-while следующая:

do {
оператор;
} while (условие);
Если оператор не является блоком, фигурные скобки не обязательны, но их почти всегда ставят, чтобы оператор достаточно наглядно отделялся от условия. Итерации оператора do-while выполняются, пока условие не примет значение ЛОЖЬ.
----------------------------------------------------------------------------------------------------------------
5. Каков результат выражения 010 - 1<<3

Не помню...((((
----------------------------------------------------------------------------------------------------------------
6. В чём разница между операторами | и || Приведите пример.

Оператор логического ИЛИ (||) возвращает логическое значение true, если один или оба операнда имеют значение true; в противном случае он возвращает значение false. Перед вычислением оба операнда неявно преобразуются в тип bool; результат также имеет тип bool. Логическое ИЛИ имеет ассоциативность в направлении слева направо.
Операнды оператора логического ИЛИ не обязаны относиться к одному и тому же типу, однако должны иметь целочисленный тип или тип указателя. В качестве операндов часто используются реляционные выражения и выражения равенства.
В выражении логического ИЛИ сначала полностью вычисляется первый операнд и учитываются все побочные эффекты, и лишь после этого вычисление продолжается.
Второй операнд вычисляется только в том случае, если первый имеет значение false (0). Это исключает необязательное вычисление второго операнда, если выражение логического ИЛИ имеет значение true.
printf( "%d" , (x == w || x == y || x == z) );
В приведенном выше примере, если x равно w, y или z, то второй аргумент функции printf имеет значение true и код выводит значение 1. В противном случае он возвращает значение false и код выводит значение 0. Как только обнаруживается, что одно из значений равно true, вычисление прекращается.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Оператор логического И (&&) возвращает логическое значение true, если оба операнда имеют значение true; в противном случае он возвращает значение false. Перед вычислением оба операнда неявно преобразуются в тип bool; результат также имеет тип bool. Логическое И имеет ассоциативность в направлении слева направо.
Операнды оператора логического И не должны быть одинакового типа, но должны быть целочисленного типа или типа указателя. В качестве операндов часто используются реляционные выражения и выражения равенства.
Перед продолжением вычисления выражения логического И полностью вычисляется первый операнд и учитываются все побочные эффекты.
Второй операнд вычисляется только в том случае, если результат вычисления первого операнда — значение true (не нуль). Такое вычисление исключает необязательное вычисление второго операнда, если выражение логического И имеет значение false. Такое сокращенное вычисление можно использовать для предотвращения разыменования пустого указателя, как показано в следующем примере.
char *pch = 0;
...
(pch) && (*pch = 'a');
Если pch имеет значение NULL (0), правая часть выражения никогда не вычисляется. Поэтому присваивание с помощью пустого указателя невозможно.
----------------------------------------------------------------------------------------------------------------
7. Каков результат выражения 1/2

Не помню...(((
----------------------------------------------------------------------------------------------------------------
8. Какая вычислительная сложность алгоритма сортировки пузырьком?

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. Алгоритм имеет такое название из-за того, что на каждой итерации наименьший элемент (самый лёгкий) «всплывает» до своей позиции. Ниже дан пример реализации этого алгоритма.
Сортировка пузырьком обладает следующими свойствами:
Высокая вычислительная сложность, необходимо сделать O(N2) сравнений и O(N2) перестановок. Если данные уже отсортированы, то необходимо сделать всего O(N) операций;
Не требует использования дополнительной памяти (O(1));
Устойчива;
Простота в реализации.
----------------------------------------------------------------------------------------------------------------
9. Отранжируйте вычислительные сложности: O(N), O(1), O(N log N), O(N^2), O(log N), O(exp N)

Не могу...(((
----------------------------------------------------------------------------------------------------------------
10. Для чего нужны массивы?

Массив — упорядоченный набор данных, для хранения данных одного типа, идентифицируемых с помощью одного или нескольких индексов. В простейшем случае массив имеет постоянную длину и хранит единицы данных одного и того же типа.

Количество используемых индексов массива может быть различным. Массивы с одним индексом называют одномерными, с двумя — двумерными и т. д. Одномерный массив нестрого соответствует вектору в математике, двумерный — матрице. Чаще всего применяются массивы с одним или двумя индексами, реже — с тремя, ещё большее количество индексов встречается крайне редко.
Лёгкость вычисления адреса элемента по его индексу (поскольку элементы массива располагаются один за другим)
Одинаковое время доступа ко всем элементам
Малый размер элементов: они состоят только из информационного поля.
Нужны для облегчения работы с множество чисел,для экономии времени,поиска.
----------------------------------------------------------------------------------------------------------------
11. Что хранится в статической памяти?

Конфигурационные данные,загружаемые во время включения питания.
Кэширование оперативной памяти,кэширование данных в механических устройствах хранения информации, в блоках памяти видеоадаптеров.
----------------------------------------------------------------------------------------------------------------
12. Почему использование глобальных переменных может приводить к ошибкам?

В отличие от локальных, глобальные переменные видимы и могут использоваться в любом месте программы. Они сохраняют свое значение на протяжении всей работы программы. Чтобы создать глобальную переменную, ее необходимо объявить за пределами функции. Глобальная переменная может быть использована в любом выражении, независимо от того, в каком блоке это выражение используется.
Глобальные переменные хранятся в отдельной фиксированной области памяти, созданной компилятором специально для этого. Глобальные переменные используются в тех случаях, когда разные функции программы используют одни и те же данные. Однако рекомендуется избегать излишнего использования глобальных переменных, потому что они занимают память в течение всего времени выполнения программы, а не только тогда, когда они необходимы. Кроме того, и это еще более важно, использование глобальной переменной делает функцию менее универсальной, потому что в этом случае функция использует нечто, определенное вне ее. К тому же большое количество глобальных переменных легко приводит к ошибкам в программе из-за нежелательных побочных эффектов. При увеличении размера программы серьезной проблемой становится случайное изменение значения переменной где-то в другой части программы, а когда глобальных переменных много, предотвратить это очень трудно.
----------------------------------------------------------------------------------------------------------------
